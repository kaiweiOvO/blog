<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>异常处理</title>
		<link rel="stylesheet" type="text/css" href="../css/demo.css"/>
		<link rel="stylesheet" type="text/css" href="../css/animation.css"/>
		<link rel="stylesheet" type="tex t/css" href="../css/Class.css"/>
		<link rel="stylesheet" type="text/css" href="../css/font-awesome-4.7.0/css/font-awesome.css"/>
		<link rel="stylesheet" type="text/css" href="../css/font-awesome-4.7.0/css/font-awesome.min.css"/>
		<script src="../js/jquery-3.3.1.js"></script>
		<script src="../js/jquery-3.3.1.min.js"></script>
		<script src="../js/rgb.js"></script>	
		<script src="../js/demo.js"></script>
	</head>
	<body>
		<header id="header">
			<p>Personal Note</p>
			<p style="color: transparent;">by @kaiweiOvO</p>
		</header>
		<section id="section">
			<ul id="menu">
				<li><a style="text-align: center; padding:0; height: 23px; font-size: 22px;">JAVA</a></li>
				<li><a href="数据类型.html">数据类型<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="循环结构.html">循环结构<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="分支结构.html">分支结构<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="方法.html">方法<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="构造器（构造方法）.html">构造器<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="修饰符.html">修饰符<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="继承.html">继承<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="重写和重载.html">重写和重载<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="多态.html">多态<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="封装.html">封装<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="抽象类.html">抽象类<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="接口.html">接口<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
				<li><a href="javascript:(0)">异常处理<i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
			</ul>
			<div class="content">
				<div class="tp_p_n">
					<div><i class="fa fa-chevron-left" aria-hidden="true"></i><a href="接口.html">preview</a></div>
					<div><a href="javascript:(0)">next</a><i class="fa fa-chevron-right" aria-hidden="true"></i></div>
				</div>
				<div class="main_content">
					<h1>异常处理</h1>
					<p>
					 异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。
					 </p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。
					 </p>
					 <p>异常发生的原因有很多，通常包含以下几大类：</p>
					 <ul>
						<li>用户输入了非法数据。</li>
						<li>要打开的文件不存在。</li>
						<li>网络通信时连接中断，或者JVM内存溢出。</li>
					</ul>
					<p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-<br />
					</p><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：
					</p><ul>
						<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
						<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
						<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
					</ul>
					<hr><h2>Exception 类的层次</h2>
					
					<p>所有的异常类是从 java.lang.Exception 类继承的子类。
					</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。
					</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。
					</p><p>Error 用来指示运行时环境发生的错误。
					</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。
					</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p>
					<p>
					在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。
					</p>
					<hr>
					<h2>Java 内置异常类</h2>
					<p>Java 语言定义了一些异常类在 java.lang 标准包中。
					</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。
					</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。
					 </p>
					 <table cellspacing="0">
						<tbody>
							<tr>
								<th>
									<strong>异常</strong></th>
								<th>
									<strong>描述</strong></th>
							</tr>
							<tr>
								<td>
									ArithmeticException</td>
								<td>
									当出现异常的运算条件时，抛出此异常。例如，一个整数"除以零"时，抛出此类的一个实例。</td>
							</tr>
							<tr>
								<td>
									ArrayIndexOutOfBoundsException</td>
								<td>
									用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
							</tr>
							<tr>
								<td>
									ArrayStoreException</td>
								<td>
									试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
							</tr>
							<tr>
								<td>
									ClassCastException</td>
								<td>
									当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									IllegalArgumentException</td>
								<td>
									抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
							</tr>
							<tr>
								<td>
									IllegalMonitorStateException</td>
								<td>
									抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
							</tr>
							<tr>
								<td>
									IllegalStateException</td>
								<td>
									在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
							</tr>
							<tr>
								<td>
									IllegalThreadStateException</td>
								<td>
									线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
							</tr>
							<tr>
								<td>
									IndexOutOfBoundsException</td>
								<td>
									指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
							</tr>
							<tr>
								<td>
									NegativeArraySizeException</td>
								<td>
									如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
							</tr>
							<tr>
								<td>
									NullPointerException</td>
								<td>
									当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td>
							</tr>
							<tr>
								<td>
									NumberFormatException</td>
								<td>
									当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									SecurityException</td>
								<td>
									由安全管理器抛出的异常，指示存在安全侵犯。</td>
							</tr>
							<tr>
								<td>
									StringIndexOutOfBoundsException</td>
								<td>
									此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
							</tr>
							<tr>
								<td>
									UnsupportedOperationException</td>
								<td>
									当不支持请求的操作时，抛出该异常。</td>
							</tr>
						</tbody>
					</table>
					<p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。
					</p>
					<table cellspacing="0">
						<tbody>
							<tr>
								<th>
									<strong>异常</strong></th>
								<th>
									<strong>描述</strong></th>
							</tr>
							<tr>
								<td>
									ClassNotFoundException</td>
								<td>
									应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									CloneNotSupportedException</td>
								<td>
									当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									IllegalAccessException</td>
								<td>
									拒绝访问一个类的时候，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									InstantiationException</td>
								<td>
									当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									InterruptedException</td>
								<td>
									一个线程被另一个线程中断，抛出该异常。</td>
							</tr>
							<tr>
								<td>
									NoSuchFieldException</td>
								<td>
									请求的变量不存在</td>
							</tr>
							<tr>
								<td>
									NoSuchMethodException</td>
								<td>
									请求的方法不存在</td>
							</tr>
						</tbody>
					</table>
					<hr>
					<h2>
					异常方法
					</h2>
					<p>
					
					下面的列表是 Throwable 类的主要方法:</p>
					<table cellspacing="0">
						<tbody>
							<tr>
								<th>
									<strong>序号</strong></th>
								<th>
									<strong>方法及说明</strong></th>
							</tr>
							<tr>
								<td>
									1</td>
								<td>
									<strong>public String getMessage()</strong><br>
									返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td>
							</tr>
							<tr>
								<td>
									2</td>
								<td>
									<strong>public Throwable getCause()</strong><br>
									返回一个Throwable 对象代表异常原因。</td>
							</tr>
							<tr>
								<td>
									3</td>
								<td>
									<strong>public String toString()</strong><br>
									使用getMessage()的结果返回类的串级名字。</td>
							</tr>
							<tr>
								<td>
									4</td>
								<td>
									<strong>public void printStackTrace()</strong><br>
									打印toString()结果和栈层次到System.err，即错误输出流。</td>
							</tr>
							<tr>
								<td>
									5</td>
								<td>
									<strong>public StackTraceElement [] getStackTrace()</strong><br>
									返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td>
							</tr>
							<tr>
								<td>
									6</td>
								<td>
									<strong>public Throwable fillInStackTrace()</strong><br>
									用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td>
							</tr>
						</tbody>
					</table>
					<hr>
					<h2>
					捕获异常</h2>
					<p>
					
					使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。
					</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：
					</p>
					<pre>
					
		try
		{
		   // 程序代码
		}catch(ExceptionName e1)
		{
		   //Catch 块
		}
					</pre>
					<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。
					</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。
					</p>
					<hr><h2>多重捕获块</h2>
					<p>
					一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。
					</p><p>多重捕获块的语法如下所示：</p>
					<pre>
						
		try{
		   // 程序代码
		}catch(异常类型1 异常的变量名1){
		  // 程序代码
		}catch(异常类型2 异常的变量名2){
		  // 程序代码
		}catch(异常类型2 异常的变量名2){
		  // 程序代码
		}				
					</pre>
					<p>上面的代码段包含了 3 个 catch块。
					</p><p>可以在 try 语句后面添加任意数量的 catch 块。
					</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。
					</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。
					</p><p>如果不匹配，它会被传递给第二个 catch 块。
					</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p>
					<h3>实例</h3>
					<p>
					该实例展示了怎么使用多重 try/catch。
					</p>
					<pre>
						
		try {
		    file = new FileInputStream(fileName);
		    x = (byte) file.read();
		} catch(FileNotFoundException f) { // Not valid!
		    f.printStackTrace();
		    return -1;
		} catch(IOException i) {
		    i.printStackTrace();
		    return -1;
		}				
					</pre>
					<hr>
					<h2>
					throws/throw 关键字：
					</h2>
					<p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。
					</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。
					</p><p>由throw/throws抛出的异常本身不会解决，由调用此方法的方法解决不然可以继续使用throw/throws抛出错误</p>
					<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。
					<p>例如</p>
					<pre>
						
		public class test{
			public void throwException() throw RemoteException,InsufficientFundsException
			{
				//method				
			}
		}				
					</pre>
					<hr>
					<h2>
					finally关键字
					</h2>
					<p>finally 关键字用来创建在 try 代码块后面执行的代码块。
					</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。
					</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。
					</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p>
					<pre>
						
		try{
			Scanner sc = new Scanner(System.in);
			int n = sc.nextInt();
		}catch(Exception e){
			System.out.println(e);
		}finally{
			System.out.println("finally excuted");
		}		
					</pre>
					<p align="center">copy by <a href="https://www.runoob.com/">@菜鸟教程</a></p>	



				</div>
				<div class="bt_p_n">
					<div><i class="fa fa-chevron-left" aria-hidden="true"></i><a href="多态.html">preview</a></div>
					<div><a href="javascript:(0)">next</a><i class="fa fa-chevron-right" aria-hidden="true"></i></div>
				</div>
			</div>
			<div style="clear: both;"></div>
		</section>
		<footer id="fot" class="fot">
			<div id="about" class="about">
				<div id="b_nav" class="b_nav">
					<ul>
						<li><a href="../index.html">Home</a></li>
						<li><a href="#header">Top</a></li>
						<li><a href="#csl">About</a></li>
					</ul>
				</div>
				<p>个人网站&nbsp;<a id="kaiweiOvO">@kaiweiOvO</a>&nbsp;Copyright&nbsp;&copy;&nbsp;2019</p>
				<p>QQ&emsp;859438315</p>
				<p>e_mail&emsp;kaiweiOvO@163.com</p>
				<p>wechat</p>
				<img src="../img/IMG_3529.PNG"/>
			</div>
		</footer>
	</body>
</html>
